---- MODULE BrachaBRB ----
EXTENDS TLC, Naturals, FiniteSets, Sequences

CONSTANTS
  Proc,       \* set of processes
  Values,     \* broadcast values
  Byzantine,  \* subset of Proc
  Initiator   \* designated broadcaster

ASSUME
  Byzantine \subseteq Proc
  /\ Initiator \in Proc

n == Cardinality(Proc)
t == Cardinality(Byzantine)

(* Helper to treat sequence elements as a set *)
Range(s) == { s[i] : i \in 1..Len(s) }

(* Helper for non-faulty processes *)
CorrectProc == Proc \ Byzantine
Correct(p) == p \notin Byzantine

(*--algorithm BrachaBRB

variables
  msgs      = {},                     \* messages in transit
  msgBuffer = {},                     \* temporary buffer for messages
  sentREADY = [p \in Proc |-> {}],    \* READY broadcast
  recvINIT  = [p \in Proc |-> {}],    \* first INIT seen
  recvECHO  = [p \in Proc |-> {}],
  recvREADY = [p \in Proc |-> {}],
  delivered = [p \in Proc |-> << >>]; \* delivered BRB pairs, initialized as a sequence due to integrity

define
  (*====Utility functions====*)
  INIT(orig, val) ==
    [ type |-> "INIT",
      orig |-> orig,
      val  |-> val ]

  ECHO(orig, val) ==
    [ type |-> "ECHO",
      orig |-> orig,
      val  |-> val ]

  READY(orig, val) ==
    [ type |-> "READY",
      orig |-> orig,
      val  |-> val ]
    
  RecvEnough(msgSet, msg, proc, count) ==
    LET RelevantMsgs == { m \in msgSet[proc] : 
                          m.orig = msg.orig /\ m.val = msg.val }
        Senders == { m.from : m \in RelevantMsgs }
    IN 
      Cardinality(Senders) > count

  (* Helper to check if a pair exists in a sequence *)
  IsDelivered(orig, val, proc) ==
    \E i \in 1..Len(delivered[proc]) : 
        delivered[proc][i].orig = orig /\ delivered[proc][i].val = val

  (*====Properties====*)

  (* BRB-integrity: No correct process delivers a message more than once. *)
  (* This is now a powerful check: it fails if the same message appears 
     at two different indices in the delivery sequence. *)
  BRB_Integrity ==
    \A proc \in CorrectProc :
      \A i, j \in 1..Len(delivered[proc]) :
        (i /= j) => (delivered[proc][i] /= delivered[proc][j])
  
  (* BRB-validity: If a non-faulty process delivers from a correct Initiator, 
     it must match what the Initiator actually sent. *)
  BRB_Validity == 
    \A proc \in CorrectProc :
      \A d \in Range(delivered[proc]) :
        (d.orig = Initiator /\ Correct(Initiator)) => 
          (d.val \in Values)
  
  (* BRB-no-duplicity: No two non-faulty processes deliver distinct messages 
     from the same sender (even if that sender is Byzantine). *)
  BRB_NoDuplicity ==
    \A p1, p2 \in CorrectProc :
      \A d1 \in Range(delivered[p1]), d2 \in Range(delivered[p2]) :
        (d1.orig = d2.orig) => (d1.val = d2.val) 
  (* BRB-termination-1: If the sender is non-faulty, all non-faulty 
     processes eventually deliver its message. *)
  BRB_Termination1 ==
    Correct(Initiator) => 
      \A proc \in CorrectProc :
        <>(\E d \in Range(delivered[proc]) : d.orig = Initiator)
  
  (* BRB-termination-2: If a non-faulty process delivers a message from 
     any p_i, then all non-faulty processes eventually deliver from p_i. *)
  BRB_Termination2 ==
    \A proc \in CorrectProc :
      \A d \in Range(delivered[proc]) :
        \A q \in CorrectProc : 
          <>(\E d2 \in Range(delivered[q]) : d2.orig = d.orig)
  
  (* Contraints *)
  StateConstraint == 
    /\ Cardinality(msgs) < 10
    /\ \A p \in Proc : Len(delivered[p]) < 2
end define;

(* simple broadcast macro *)
macro SendAll(msg, proc) begin
  msgBuffer := { [type |-> msg.type, from |-> proc, to |-> q,
                   orig |-> msg.orig, val |-> msg.val] : q \in Proc };
end macro;

macro Deliver(msg, proc) begin
    \* delivered[p] := delivered[p] \union [orig |-> msg.orig, val |-> msg.val];
    delivered[proc] := Append(delivered[proc], [orig |-> msg.orig, val |-> msg.val]);
end macro;

macro HandleInit(proc, msg) begin
  (* only INIT messages are checked for first reception *)
  if msg \notin recvINIT[proc] then
    recvINIT[proc] := recvINIT[proc] \union {msg};
    SendAll(ECHO(msg.orig, msg.val), proc);
  end if;
end macro;

macro HandleEcho(proc, msg) begin
  recvECHO[proc] := recvECHO[proc] \union {msg};
  with recvEnoughEcho = RecvEnough(recvECHO, msg, proc, (n + t) \div 2),
       readyMsg = READY(msg.orig, msg.val),
       notYetBroadcast = readyMsg \notin sentREADY[proc] do
    if recvEnoughEcho /\ notYetBroadcast then
        SendAll(readyMsg, proc);
        sentREADY[proc] := sentREADY[proc] \union {readyMsg};
    end if;
  end with;
end macro;

macro HandleReady(proc, msg) begin
  recvREADY[proc] := recvREADY[proc] \union {msg};
  (* algorithm specifies "received from (t + 1) different processors", *)
  (* which translates to more than t different processors *)
  with recvEnoughForBroadcast = RecvEnough(recvREADY, msg, proc, t),
       readyMsg = READY(msg.orig, msg.val),
       notYetBroadcast = readyMsg \notin sentREADY[proc] do
    if recvEnoughForBroadcast /\ notYetBroadcast then
        SendAll(readyMsg, proc);
        sentREADY[proc] := sentREADY[proc] \union {readyMsg};
    end if;
  end with;

  (* algorithm specifies "received from (2t + 1) different processors" *)
  with recvEnoughForDeliver = RecvEnough(recvREADY, msg, proc, 2 * t),
       notYetDelivered = ~IsDelivered(msg.orig, msg.val, proc) do
    if recvEnoughForDeliver /\ notYetDelivered then
        Deliver(msg, proc);
    end if;
  end with;
end macro;

fair process p \in (Proc \ Byzantine)
begin
  InitStep:
    if self = Initiator /\ Correct(self) then
      with m \in Values do
        SendAll(INIT(self, m), self);
        msgs := msgs \union msgBuffer;
      end with;
    end if;

  ClearBuffer:
    msgBuffer := {};
  HandleMsg:
    either
      \* deliver any pending message that is sent to p
      with msg \in {m \in msgs : m.to = self} do
        if msg.type = "INIT" then
          HandleInit(self, msg);
        elsif msg.type = "ECHO" then
          HandleEcho(self, msg);
        else
          HandleReady(self, msg);
        end if;
        msgs := (msgs \ {msg}) \union msgBuffer;
      end with;
    or
      skip;
    end either;
    goto ClearBuffer;
end process;

fair process b \in Byzantine
begin
  ByzantineStep:
    either
      \* arbitrary Byzantine message send
      with q \in Proc, j \in Proc, m \in Values,
           ty \in {"INIT", "ECHO", "READY"} do
        msgs := msgs \union
          { [type |-> ty, from |-> self, to |-> q,
             orig |-> j, val |-> m] };
      end with;
    or
      skip;
    end either;
    goto ByzantineStep;
end process;

end algorithm; *)

====
